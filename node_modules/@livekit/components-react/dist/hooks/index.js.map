{"version":3,"sources":["../../src/hooks/index.ts","../../src/hooks/useAudioPlayback.ts","../../src/hooks/internal/useResizeObserver.ts","../../src/hooks/internal/useObservableState.ts","../../src/context/layout-context.ts","../../src/context/participant-context.ts","../../src/context/track-reference-context.ts","../../src/context/room-context.ts","../../src/hooks/useClearPinButton.ts","../../src/mergeProps.ts","../../src/hooks/useConnectionQualityIndicator.ts","../../src/hooks/useConnectionStatus.ts","../../src/hooks/useDataChannel.ts","../../src/hooks/useDisconnectButton.ts","../../src/hooks/useFacingMode.ts","../../src/hooks/useFocusToggle.ts","../../src/hooks/useGridLayout.ts","../../src/hooks/useIsMuted.ts","../../src/hooks/useIsSpeaking.ts","../../src/hooks/useLiveKitRoom.ts","../../src/hooks/useLocalParticipant.ts","../../src/hooks/useLocalParticipantPermissions.ts","../../src/hooks/useMediaDeviceSelect.ts","../../src/hooks/useMediaDevices.ts","../../src/hooks/useMediaTrackBySourceOrName.ts","../../src/utils.ts","../../src/hooks/useMediaTrack.ts","../../src/hooks/useMediaTrackByName.ts","../../src/hooks/usePagination.ts","../../src/hooks/useVisualStableUpdate.ts","../../src/hooks/useParticipantInfo.ts","../../src/hooks/useParticipantPermissions.ts","../../src/hooks/useParticipantTile.ts","../../src/hooks/useRemoteParticipants.ts","../../src/hooks/useParticipants.ts","../../src/hooks/usePinnedTracks.ts","../../src/hooks/useRemoteParticipant.ts","../../src/hooks/useRoomInfo.ts","../../src/hooks/useSortedParticipants.ts","../../src/hooks/useSpeakingParticipants.ts","../../src/hooks/useStartAudio.ts","../../src/hooks/useStartVideo.ts","../../src/hooks/useSwipe.ts","../../src/hooks/useChatToggle.ts","../../src/hooks/useToken.ts","../../src/hooks/useTrackMutedIndicator.ts","../../src/hooks/useTrackToggle.ts","../../src/hooks/useTracks.ts","../../src/hooks/useTrack.ts","../../src/hooks/useTrackByName.ts","../../src/hooks/useChat.ts","../../src/hooks/usePersistentUserChoices.ts","../../src/hooks/useIsEncrypted.ts","../../src/hooks/useTrackVolume.ts"],"sourcesContent":["export { useAudioPlayback } from './useAudioPlayback';\nexport { useClearPinButton } from './useClearPinButton';\nexport {\n  ConnectionQualityIndicatorOptions,\n  useConnectionQualityIndicator,\n} from './useConnectionQualityIndicator';\nexport { useConnectionState } from './useConnectionStatus';\nexport { useDataChannel } from './useDataChannel';\nexport { useDisconnectButton } from './useDisconnectButton';\nexport { useFacingMode } from './useFacingMode';\nexport { UseFocusToggleProps, useFocusToggle } from './useFocusToggle';\nexport { useGridLayout } from './useGridLayout';\nexport { UseIsMutedOptions, useIsMuted } from './useIsMuted';\nexport { useIsSpeaking } from './useIsSpeaking';\nexport { useLiveKitRoom } from './useLiveKitRoom';\nexport { UseLocalParticipantOptions, useLocalParticipant } from './useLocalParticipant';\nexport { useLocalParticipantPermissions } from './useLocalParticipantPermissions';\nexport { UseMediaDeviceSelectProps, useMediaDeviceSelect } from './useMediaDeviceSelect';\nexport { useMediaDevices } from './useMediaDevices';\nexport { UseMediaTrackOptions, useMediaTrack } from './useMediaTrack';\nexport { useMediaTrackByName } from './useMediaTrackByName';\nexport { usePagination } from './usePagination';\nexport { UseParticipantInfoOptions, useParticipantInfo } from './useParticipantInfo';\nexport {\n  UseParticipantPermissionsOptions,\n  useParticipantPermissions,\n} from './useParticipantPermissions';\nexport { UseParticipantTileProps, useParticipantTile } from './useParticipantTile';\nexport { UseParticipantsOptions, useParticipants } from './useParticipants';\nexport { usePinnedTracks } from './usePinnedTracks';\nexport { UseRemoteParticipantOptions, useRemoteParticipant } from './useRemoteParticipant';\nexport { UseRemoteParticipantsOptions, useRemoteParticipants } from './useRemoteParticipants';\nexport { UseRoomInfoOptions, useRoomInfo } from './useRoomInfo';\nexport { useSortedParticipants } from './useSortedParticipants';\nexport { useSpeakingParticipants } from './useSpeakingParticipants';\nexport { UseStartAudioProps, useStartAudio } from './useStartAudio';\nexport { UseStartVideoProps, useStartVideo } from './useStartVideo';\nexport { UseSwipeOptions, useSwipe } from './useSwipe';\nexport { UseChatToggleProps, useChatToggle } from './useChatToggle';\nexport { UseTokenOptions, UserInfo, useToken } from './useToken';\nexport { UseTrackMutedIndicatorOptions, useTrackMutedIndicator } from './useTrackMutedIndicator';\nexport { UseTrackToggleProps, useTrackToggle } from './useTrackToggle';\nexport { UseTracksHookReturnType, UseTracksOptions, useTracks } from './useTracks';\nexport { UseVisualStableUpdateOptions, useVisualStableUpdate } from './useVisualStableUpdate';\nexport { UseTrackOptions, useTrack } from './useTrack';\nexport { useTrackByName } from './useTrackByName';\nexport { useChat } from './useChat';\nexport {\n  usePersistentUserChoices,\n  type UsePersistentUserChoicesOptions,\n} from './usePersistentUserChoices';\nexport { useIsEncrypted } from './useIsEncrypted';\nexport * from './useTrackVolume';\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","/* eslint-disable no-return-assign */\n/* eslint-disable no-underscore-dangle */\nimport * as React from 'react';\nimport useLatest from '@react-hook/latest';\n\n/**\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\n *\n * @internal\n */\nexport function useResizeObserver<T extends HTMLElement>(\n  target: React.RefObject<T>,\n  callback: UseResizeObserverCallback,\n) {\n  const resizeObserver = getResizeObserver();\n  const storedCallback = useLatest(callback);\n\n  React.useLayoutEffect(() => {\n    let didUnsubscribe = false;\n\n    const targetEl = target.current;\n    if (!targetEl) return;\n\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\n      if (didUnsubscribe) return;\n      storedCallback.current(entry, observer);\n    }\n\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\n\n    return () => {\n      didUnsubscribe = true;\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\n    };\n  }, [target.current, resizeObserver, storedCallback]);\n\n  return resizeObserver?.observer;\n}\n\nfunction createResizeObserver() {\n  let ticking = false;\n  let allEntries: ResizeObserverEntry[] = [];\n\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\n    allEntries = allEntries.concat(entries);\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        const triggered = new Set<Element>();\n        for (let i = 0; i < allEntries.length; i++) {\n          if (triggered.has(allEntries[i].target)) continue;\n          triggered.add(allEntries[i].target);\n          const cbs = callbacks.get(allEntries[i].target);\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\n        }\n        allEntries = [];\n        ticking = false;\n      });\n    }\n    ticking = true;\n  });\n\n  return {\n    observer,\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      observer.observe(target);\n      const cbs = callbacks.get(target) ?? [];\n      cbs.push(callback);\n      callbacks.set(target, cbs);\n    },\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      const cbs = callbacks.get(target) ?? [];\n      if (cbs.length === 1) {\n        observer.unobserve(target);\n        callbacks.delete(target);\n        return;\n      }\n      const cbIndex = cbs.indexOf(callback);\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\n      callbacks.set(target, cbs);\n    },\n  };\n}\n\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\n\nconst getResizeObserver = () =>\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\n\nexport type UseResizeObserverCallback = (\n  entry: ResizeObserverEntry,\n  observer: ResizeObserver,\n) => unknown;\n\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n  React.useLayoutEffect(() => {\n    if (target.current) {\n      const { width, height } = target.current.getBoundingClientRect();\n      setSize({ width, height });\n    }\n  }, [target.current]);\n\n  const resizeCallback = React.useCallback(\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\n    [],\n  );\n  // Where the magic happens\n  useResizeObserver(target, resizeCallback);\n  return size;\n};\n","import * as React from 'react';\n// @ts-ignore\nimport type { Observable } from 'rxjs';\n\n/**\n * @internal\n */\nexport function useObservableState<T>(observable: Observable<T> | undefined, startWith: T) {\n  const [state, setState] = React.useState<T>(startWith);\n  React.useEffect(() => {\n    // observable state doesn't run in SSR\n    if (typeof window === 'undefined' || !observable) return;\n    const subscription = observable.subscribe(setState);\n    return () => subscription.unsubscribe();\n  }, [observable]);\n  return state;\n}\n","import { PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { PinContextType } from './pin-context';\nimport type { ChatContextType } from './chat-context';\nimport { chatReducer } from './chat-context';\nimport { pinReducer } from './pin-context';\n\n/** @public */\nexport type LayoutContextType = {\n  pin: PinContextType;\n  widget: ChatContextType;\n};\n\n/** @public */\nexport const LayoutContext = React.createContext<LayoutContextType | undefined>(undefined);\n\n/**\n * Ensures that a layout context is provided via context.\n * If no layout context is provided, an error is thrown.\n * @public\n */\nexport function useLayoutContext(): LayoutContextType {\n  const layoutContext = React.useContext(LayoutContext);\n  if (!layoutContext) {\n    throw Error('Tried to access LayoutContext context outside a LayoutContextProvider provider.');\n  }\n  return layoutContext;\n}\n\n/**\n * Ensures that a layout context is provided, either via context or explicitly as a parameter.\n * If not inside a `LayoutContext` and no layout context is provided, an error is thrown.\n * @public\n */\nexport function useEnsureLayoutContext(layoutContext?: LayoutContextType) {\n  const layout = useMaybeLayoutContext();\n  layoutContext ??= layout;\n  if (!layoutContext) {\n    throw Error('Tried to access LayoutContext context outside a LayoutContextProvider provider.');\n  }\n  return layoutContext;\n}\n\n/** @public */\nexport function useCreateLayoutContext(): LayoutContextType {\n  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);\n  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);\n  return {\n    pin: { dispatch: pinDispatch, state: pinState },\n    widget: { dispatch: widgetDispatch, state: widgetState },\n  };\n}\n\n/** @public */\nexport function useEnsureCreateLayoutContext(layoutContext?: LayoutContextType): LayoutContextType {\n  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);\n  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);\n  return (\n    layoutContext ?? {\n      pin: { dispatch: pinDispatch, state: pinState },\n      widget: { dispatch: widgetDispatch, state: widgetState },\n    }\n  );\n}\n\n/**\n * Returns a layout context from the `LayoutContext` if it exists, otherwise `undefined`.\n * @public\n */\nexport function useMaybeLayoutContext(): LayoutContextType | undefined {\n  return React.useContext(LayoutContext);\n}\n","import type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeTrackRefContext } from './track-reference-context';\n\n/** @public */\nexport const ParticipantContext = React.createContext<Participant | undefined>(undefined);\n\n/**\n * Ensures that a participant is provided via context.\n * If not inside a `ParticipantContext`, an error is thrown.\n * @public\n */\nexport function useParticipantContext() {\n  const participant = React.useContext(ParticipantContext);\n  if (!participant) {\n    throw Error('tried to access participant context outside of participant context provider');\n  }\n  return participant;\n}\n\n/**\n * Returns a participant from the `ParticipantContext` if it exists, otherwise `undefined`.\n * @public\n */\nexport function useMaybeParticipantContext() {\n  return React.useContext(ParticipantContext);\n}\n\n/**\n * Ensures that a participant is provided, either via context or explicitly as a parameter.\n * If not inside a `ParticipantContext` and no participant is provided, an error is thrown.\n * @public\n */\nexport function useEnsureParticipant(participant?: Participant) {\n  const context = useMaybeParticipantContext();\n  const trackContext = useMaybeTrackRefContext();\n  const p = participant ?? context ?? trackContext?.participant;\n  if (!p) {\n    throw new Error(\n      'No participant provided, make sure you are inside a participant context or pass the participant explicitly',\n    );\n  }\n  return p;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\n\n/**\n * This context provides a `TrackReferenceOrPlaceholder` to all child components.\n * @public\n */\nexport const TrackRefContext = React.createContext<TrackReferenceOrPlaceholder | undefined>(\n  undefined,\n);\n\n/**\n * @public\n * @deprecated `TrackContext` has been renamed to `TrackRefContext`, use this as a drop in replacement.\n */\nexport const TrackContext = TrackRefContext;\n\n/**\n * Ensures that a track reference is provided via context.\n * If not inside a `TrackRefContext`, an error is thrown.\n * @public\n * @deprecated `useTrackContext` has been renamed to `useTrackRefContext`, use this as a drop in replacement.\n */\nexport function useTrackContext() {\n  return useTrackRefContext();\n}\n\n/**\n * Ensures that a track reference is provided via context.\n * If not inside a `TrackRefContext`, an error is thrown.\n * @public\n */\nexport function useTrackRefContext() {\n  const trackReference = React.useContext(TrackRefContext);\n  if (!trackReference) {\n    throw Error('tried to access track context outside of track context provider');\n  }\n  return trackReference;\n}\n\n/**\n * Returns a track reference from the `TrackContext` if it exists, otherwise `undefined`.\n * @public\n * @deprecated `useMaybeTrackContext` has been renamed to `useMaybeTrackRefContext`, use this as a drop in replacement.\n */\nexport function useMaybeTrackContext() {\n  return useMaybeTrackRefContext();\n}\n\n/**\n * Returns a track reference from the `TrackRefContext` if it exists, otherwise `undefined`.\n * @public\n */\nexport function useMaybeTrackRefContext() {\n  return React.useContext(TrackRefContext);\n}\n\n/**\n * Ensures that a track reference is provided, either via context or explicitly as a parameter.\n * If not inside a `TrackContext` and no track reference is provided, an error is thrown.\n * @public\n * @deprecated `useEnsureTrackReference` has been renamed to `useEnsureTrackRef`, use this as a drop in replacement.\n */\nexport function useEnsureTrackReference(track?: TrackReferenceOrPlaceholder) {\n  return useEnsureTrackRef(track);\n}\n\n/**\n * Ensures that a track reference is provided, either via context or explicitly as a parameter.\n * If not inside a `TrackRefContext` and no track reference is provided, an error is thrown.\n * @public\n */\nexport function useEnsureTrackRef(trackRef?: TrackReferenceOrPlaceholder) {\n  const context = useMaybeTrackRefContext();\n  const ref = trackRef ?? context;\n  if (!ref) {\n    throw new Error(\n      'No TrackRef, make sure you are inside a TrackRefContext or pass the TrackRef explicitly',\n    );\n  }\n  return ref;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\n\n/** @public */\nexport const RoomContext = React.createContext<Room | undefined>(undefined);\n\n/**\n * Ensures that a room is provided via context.\n * If no room is provided, an error is thrown.\n * @public\n */\nexport function useRoomContext() {\n  const ctx = React.useContext(RoomContext);\n  if (!ctx) {\n    throw Error('tried to access room context outside of livekit room component');\n  }\n  return ctx;\n}\n\n/**\n * Returns the room context if it exists, otherwise undefined.\n * @public\n */\nexport function useMaybeRoomContext() {\n  return React.useContext(RoomContext);\n}\n\n/**\n * Ensures that a room is provided, either via context or explicitly as a parameter.\n * If no room is provided, an error is thrown.\n * @public\n */\nexport function useEnsureRoom(room?: Room) {\n  const context = useMaybeRoomContext();\n  const r = room ?? context;\n  if (!r) {\n    throw new Error(\n      'No room provided, make sure you are inside a Room context or pass the room explicitly',\n    );\n  }\n  return r;\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport clsx from 'clsx';\n\n/**\n * Calls all functions in the order they were chained with the same arguments.\n * @internal\n */\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (const callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n\ninterface Props {\n  [key: string]: any;\n}\n\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? V : never;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Merges multiple props objects together. Event handlers are chained,\n * classNames are combined, and ids are deduplicated - different ids\n * will trigger a side-effect and re-render components hooked up with `useId`.\n * For all other props, the last prop object overrides all previous ones.\n * @param args - Multiple sets of props to merge together.\n * @internal\n */\nexport function mergeProps<T extends Props[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\n  // Start with a base clone of the first argument. This is a lot faster than starting\n  // with an empty object and adding properties as we go.\n  const result: Props = { ...args[0] };\n  for (let i = 1; i < args.length; i++) {\n    const props = args[i];\n    for (const key in props) {\n      const a = result[key];\n      const b = props[key];\n\n      // Chain events\n      if (\n        typeof a === 'function' &&\n        typeof b === 'function' &&\n        // This is a lot faster than a regex.\n        key[0] === 'o' &&\n        key[1] === 'n' &&\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\n        key.charCodeAt(2) <= /* 'Z' */ 90\n      ) {\n        result[key] = chain(a, b);\n\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\n      } else if (\n        (key === 'className' || key === 'UNSAFE_className') &&\n        typeof a === 'string' &&\n        typeof b === 'string'\n      ) {\n        result[key] = clsx(a, b);\n      } else {\n        result[key] = b !== undefined ? b : a;\n      }\n    }\n  }\n\n  return result as UnionToIntersection<TupleTypes<T>>;\n}\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport { ConnectionQuality } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface ConnectionQualityIndicatorOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\n * @example\n * ```tsx\n * const { quality } = useConnectionQualityIndicator();\n * // or\n * const { quality } = useConnectionQualityIndicator({ participant });\n * ```\n * @public\n */\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n\n  const { className, connectionQualityObserver } = React.useMemo(\n    () => setupConnectionQualityIndicator(p),\n    [p],\n  );\n\n  const quality = useObservableState(connectionQualityObserver, ConnectionQuality.Unknown);\n\n  return { className, quality };\n}\n","import { connectionStateObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\n *\n * @example\n * ```tsx\n * const connectionState = useConnectionState(room);\n * ```\n * @public\n */\nexport function useConnectionState(room?: Room) {\n  // passed room takes precedence, if not supplied get current room context\n  const r = useEnsureRoom(room);\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\n  const connectionState = useObservableState(observable, r.state);\n  return connectionState;\n}\n","import type { DataSendOptions, ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataSendOptions) => void;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * By optionally passing a `topic`, you can narrow down which messages are returned in the messages array.\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message, send } = useDataChannel('chat');\n * ```\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants\n * const { message, send } = useDataChannel(callback);\n * ```\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { setupDisconnectButton } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { DisconnectButtonProps } from '../components';\nimport { useRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\n * custom implementation of it. It adds onClick handler to the button to disconnect\n * from the room.\n *\n * @example\n * ```tsx\n * const { buttonProps } = useDisconnectButton();\n * return <button {...buttonProps}>Disconnect</button>;\n * ```\n * @public\n */\nexport function useDisconnectButton(props: DisconnectButtonProps) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n\n  const buttonProps = React.useMemo(() => {\n    const { className, disconnect } = setupDisconnectButton(room);\n    const mergedProps = mergeProps(props, {\n      className,\n      onClick: () => disconnect(props.stopTracks ?? true),\n      disabled: connectionState === ConnectionState.Disconnected,\n    });\n    return mergedProps;\n  }, [room, props, connectionState]);\n\n  return { buttonProps };\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\n\n/**\n * Try to determine the `facingMode` of a local participant video track.\n * @remarks\n * Works only on local video tracks.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @alpha\n */\nexport function useFacingMode(\n  trackReference: TrackReferenceOrPlaceholder,\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\n  if (trackReference.publication instanceof LocalTrackPublication) {\n    const localTrack = trackReference.publication.track;\n    if (localTrack) {\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\n      return facingMode;\n    }\n  }\n  return 'undefined';\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\nimport type { Track, Participant } from 'livekit-client';\nimport { useEnsureParticipant, useMaybeLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseFocusToggleProps {\n  trackRef?: TrackReferenceOrPlaceholder;\n  /** @deprecated This parameter will be removed in a future version use `trackRef` instead. */\n  trackSource?: Track.Source;\n  /** @deprecated This parameter will be removed in a future version use `trackRef` instead. */\n  participant?: Participant;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\n *\n * @example\n * ```tsx\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\n * ```\n * @public\n */\nexport function useFocusToggle({ trackRef, trackSource, participant, props }: UseFocusToggleProps) {\n  const p = useEnsureParticipant(participant);\n  if (!trackRef && !trackSource) {\n    throw new Error('trackRef or trackSource must be defined.');\n  }\n  const layoutContext = useMaybeLayoutContext();\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\n\n  const inFocus: boolean = React.useMemo(() => {\n    if (trackRef) {\n      return isTrackReferencePinned(trackRef, layoutContext?.pin.state);\n    } else if (trackSource) {\n      const track = p.getTrack(trackSource);\n      if (layoutContext?.pin.state && track) {\n        return isTrackReferencePinned(\n          { participant: p, source: trackSource, publication: track },\n          layoutContext.pin.state,\n        );\n      } else {\n        return false;\n      }\n    } else {\n      throw new Error('trackRef or trackSource and participant must be defined.');\n    }\n  }, [trackRef, layoutContext?.pin.state, p, trackSource]);\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          // Call user defined on click callbacks.\n          props.onClick?.(event);\n\n          // Set or clear focus based on current focus state.\n          if (trackRef) {\n            if (inFocus) {\n              layoutContext?.pin.dispatch?.({\n                msg: 'clear_pin',\n              });\n            } else {\n              layoutContext?.pin.dispatch?.({\n                msg: 'set_pin',\n                trackReference: trackRef,\n              });\n            }\n          } else if (trackSource) {\n            const track = p.getTrack(trackSource);\n            if (layoutContext?.pin.dispatch && track) {\n              if (inFocus) {\n                layoutContext.pin.dispatch({\n                  msg: 'clear_pin',\n                });\n              } else {\n                layoutContext.pin.dispatch({\n                  msg: 'set_pin',\n                  trackReference: {\n                    participant: p,\n                    publication: track,\n                    source: track.source,\n                  },\n                });\n              }\n            }\n          }\n        },\n      }),\n    [props, className, trackRef, trackSource, inFocus, layoutContext?.pin, p],\n  );\n\n  return { mergedProps, inFocus };\n}\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\nimport type { GridLayoutDefinition } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useSize } from './internal';\n\n/**\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\n * If the available screen space is not enough, it will reduce the number of maximum visible\n * tiles and select a layout that still works visually within the given limitations.\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\n * while trying to display important tiles such as speaking participants or screen shares.\n *\n * @example\n * ```tsx\n * const { layout } = useGridLayout(gridElement, trackCount);\n * ```\n * @public\n */\nexport function useGridLayout(\n  /** HTML element that contains the grid. */\n  gridElement: React.RefObject<HTMLDivElement>,\n  /** Count of tracks that should get layed out */\n  trackCount: number,\n): { layout: GridLayoutDefinition } {\n  const { width, height } = useSize(gridElement);\n\n  const layout =\n    width > 0 && height > 0\n      ? selectGridLayout(GRID_LAYOUTS, trackCount, width, height)\n      : GRID_LAYOUTS[0];\n\n  React.useEffect(() => {\n    if (gridElement.current && layout) {\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\n    }\n  }, [gridElement, layout]);\n\n  return {\n    layout,\n  };\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  getTrackReferenceId,\n  mutedObserver,\n} from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\n\n/** @public */\nexport interface UseIsMutedOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\n * It returns a `boolean` that indicates if the track is muted or not.\n *\n * @example\n * ```tsx\n * const isMuted = useIsMuted(track);\n * ```\n * @public\n */\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\n/** @public @deprecated This overload will be removed in a future version, pass in trackRef instead. */\nexport function useIsMuted(source: Track.Source, options?: UseIsMutedOptions): boolean;\nexport function useIsMuted(\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\n  options: UseIsMutedOptions = {},\n) {\n  const passedParticipant =\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\n  const p = useEnsureParticipant(passedParticipant);\n  const ref =\n    typeof sourceOrTrackRef === 'string'\n      ? { participant: p, source: sourceOrTrackRef }\n      : sourceOrTrackRef;\n  const [isMuted, setIsMuted] = React.useState(\n    !!(ref.publication?.isMuted || p.getTrack(ref.source)?.isMuted),\n  );\n\n  React.useEffect(() => {\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\n    return () => listener.unsubscribe();\n  }, [getTrackReferenceId(ref)]);\n\n  return isMuted;\n}\n","import { createIsSpeakingObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\n * @example\n * ```tsx\n * const isSpeaking = useIsSpeaking(participant);\n * ```\n * @public\n */\nexport function useIsSpeaking(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\n\n  return isSpeaking;\n}\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\nimport { Room, MediaDeviceFailure, RoomEvent, ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { HTMLAttributes } from 'react';\n\nimport type { LiveKitRoomProps } from '../components';\nimport { mergeProps } from '../mergeProps';\n\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\n  connect: true,\n  audio: false,\n  video: false,\n};\n\n/**\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\n *\n * @example\n * ```tsx\n * const { room, htmlProps } = useLiveKitRoom();\n * return <div {...htmlProps}>...</div>;\n * ```\n * @public\n */\nexport function useLiveKitRoom<T extends HTMLElement>(\n  props: LiveKitRoomProps,\n): {\n  room: Room | undefined;\n  htmlProps: HTMLAttributes<T>;\n} {\n  const {\n    token,\n    serverUrl,\n    options,\n    room: passedRoom,\n    connectOptions,\n    connect,\n    audio,\n    video,\n    screen,\n    onConnected,\n    onDisconnected,\n    onError,\n    onMediaDeviceFailure,\n    onEncryptionError,\n    simulateParticipants,\n    ...rest\n  } = { ...defaultRoomProps, ...props };\n  if (options && passedRoom) {\n    log.warn(\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\n    );\n  }\n\n  const [room, setRoom] = React.useState<Room | undefined>();\n\n  React.useEffect(() => {\n    setRoom(passedRoom ?? new Room(options));\n  }, [passedRoom]);\n\n  const htmlProps = React.useMemo(() => {\n    const { className } = setupLiveKitRoom();\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\n  }, [rest]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const onSignalConnected = () => {\n      const localP = room.localParticipant;\n\n      log.debug('trying to publish local tracks');\n      Promise.all([\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\n      ]).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    };\n\n    const handleMediaDeviceError = (e: Error) => {\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\n      onMediaDeviceFailure?.(mediaDeviceFailure);\n    };\n    const handleEncryptionError = (e: Error) => {\n      onEncryptionError?.(e);\n    };\n    room\n      .on(RoomEvent.SignalConnected, onSignalConnected)\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n      .on(RoomEvent.EncryptionError, handleEncryptionError);\n\n    return () => {\n      room\n        .off(RoomEvent.SignalConnected, onSignalConnected)\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n        .off(RoomEvent.EncryptionError, handleEncryptionError);\n    };\n  }, [room, audio, video, screen, onError, onEncryptionError, onMediaDeviceFailure]);\n\n  React.useEffect(() => {\n    if (!room) return;\n\n    if (simulateParticipants) {\n      room.simulateParticipants({\n        participants: {\n          count: simulateParticipants,\n        },\n        publish: {\n          audio: true,\n          useRealTracks: true,\n        },\n      });\n      return;\n    }\n    if (!token) {\n      log.debug('no token yet');\n      return;\n    }\n    if (!serverUrl) {\n      log.warn('no livekit url provided');\n      onError?.(Error('no livekit url provided'));\n      return;\n    }\n    if (connect) {\n      log.debug('connecting');\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    } else {\n      log.debug('disconnecting because connect is false');\n      room.disconnect();\n    }\n  }, [\n    connect,\n    token,\n    JSON.stringify(connectOptions),\n    room,\n    onError,\n    serverUrl,\n    simulateParticipants,\n  ]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const connectionStateChangeListener = (state: ConnectionState) => {\n      switch (state) {\n        case ConnectionState.Disconnected:\n          if (onDisconnected) onDisconnected();\n          break;\n        case ConnectionState.Connected:\n          if (onConnected) onConnected();\n          break;\n\n        default:\n          break;\n      }\n    };\n    room.on(RoomEvent.ConnectionStateChanged, connectionStateChangeListener);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, connectionStateChangeListener);\n    };\n  }, [token, onConnected, onDisconnected, room]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    return () => {\n      log.info('disconnecting on onmount');\n      room.disconnect();\n    };\n  }, [room]);\n\n  return { room, htmlProps };\n}\n","import type { ParticipantMedia } from '@livekit/components-core';\nimport { observeParticipantMedia } from '@livekit/components-core';\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseLocalParticipantOptions {\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useLocalParticipant` hook returns the local participant and the associated state\n * around the participant.\n *\n * @example\n * ```tsx\n * const { localParticipant } = useLocalParticipant();\n * ```\n * @public\n */\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\n    localParticipant.lastMicrophoneError,\n  );\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\n    undefined,\n  );\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\n\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\n    setIsCameraEnabled(media.isCameraEnabled);\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\n    setCameraTrack(media.cameraTrack);\n    setMicrophoneTrack(media.microphoneTrack);\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\n    setLastCameraError(media.participant.lastCameraError);\n    setLocalParticipant(media.participant);\n  };\n  React.useEffect(() => {\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\n    // TODO also listen to permission and metadata etc. events\n    return () => listener.unsubscribe();\n  }, [room]);\n\n  return {\n    isMicrophoneEnabled,\n    isScreenShareEnabled,\n    isCameraEnabled,\n    microphoneTrack,\n    cameraTrack,\n    lastMicrophoneError,\n    lastCameraError,\n    localParticipant,\n  };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\n *\n * @example\n * ```tsx\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\n * ```\n * @public\n */\nexport function useLocalParticipantPermissions() {\n  const room = useRoomContext();\n  const permissionObserver = React.useMemo(\n    () => participantPermissionObserver(room.localParticipant),\n    [room],\n  );\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\n  return permissions;\n}\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\nimport type { LocalAudioTrack, LocalVideoTrack, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseMediaDeviceSelectProps {\n  kind: MediaDeviceKind;\n  room?: Room;\n  track?: LocalAudioTrack | LocalVideoTrack;\n  /**\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\n   * appropriate permissions.\n   *\n   * @see {@link MediaDeviceMenu}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\n   */\n  requestPermissions?: boolean;\n  /**\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\n   * Most commonly this will emit a MediaDeviceError\n   */\n  onError?: (e: Error) => void;\n}\n\n/**\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\n * and a function to set the the active device.\n *\n * @example\n * ```tsx\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\n * ```\n * @public\n */\nexport function useMediaDeviceSelect({\n  kind,\n  room,\n  track,\n  requestPermissions,\n  onError,\n}: UseMediaDeviceSelectProps) {\n  const roomContext = useMaybeRoomContext();\n  // List of all devices.\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\n    [kind, requestPermissions, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  // Active device management.\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>('');\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\n    () => setupDeviceSelector(kind, room ?? roomContext, track),\n    [kind, room, roomContext, track],\n  );\n\n  React.useEffect(() => {\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\n      log.info('setCurrentDeviceId', deviceId);\n      if (deviceId) setCurrentDeviceId(deviceId);\n    });\n    return () => {\n      listener?.unsubscribe();\n    };\n  }, [activeDeviceObservable]);\n\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\n}\n","import * as React from 'react';\nimport { useObservableState } from './internal';\nimport { createMediaDeviceObserver } from '@livekit/components-core';\n\n/**\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\n *\n * @example\n * ```tsx\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\n * ```\n * @public\n */\nexport function useMediaDevices({ kind }: { kind: MediaDeviceKind }) {\n  const deviceObserver = React.useMemo(() => createMediaDeviceObserver(kind), [kind]);\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  return devices;\n}\n","import type { TrackIdentifier } from '@livekit/components-core';\nimport { isTrackReference } from '@livekit/components-core';\nimport { setupMediaTrack, log, isLocal, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { mergeProps } from '../utils';\nimport type { UseMediaTrackOptions } from './useMediaTrack';\n\n/**\n * @internal\n */\nexport function useMediaTrackBySourceOrName(\n  observerOptions: TrackIdentifier,\n  options: UseMediaTrackOptions = {},\n) {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(observerOptions));\n\n  const [isMuted, setMuted] = React.useState(publication?.isMuted);\n  const [isSubscribed, setSubscribed] = React.useState(publication?.isSubscribed);\n\n  const [track, setTrack] = React.useState(publication?.track);\n  const [orientation, setOrientation] = React.useState<'landscape' | 'portrait'>('landscape');\n  const previousElement = React.useRef<HTMLMediaElement | undefined | null>();\n\n  const { className, trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(observerOptions);\n  }, [\n    observerOptions.participant.sid ?? observerOptions.participant.identity,\n    observerOptions.source,\n    isTrackReference(observerOptions) && observerOptions.publication.trackSid,\n  ]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      log.debug('update track', publication);\n      setPublication(publication);\n      setMuted(publication?.isMuted);\n      setSubscribed(publication?.isSubscribed);\n      setTrack(publication?.track);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  React.useEffect(() => {\n    if (track) {\n      if (previousElement.current) {\n        track.detach(previousElement.current);\n      }\n      if (\n        options.element?.current &&\n        !(isLocal(observerOptions.participant) && track?.kind === 'audio')\n      ) {\n        track.attach(options.element.current);\n      }\n    }\n    previousElement.current = options.element?.current;\n    return () => {\n      if (previousElement.current) {\n        track?.detach(previousElement.current);\n      }\n    };\n  }, [track, options.element]);\n\n  React.useEffect(() => {\n    // Set the orientation of the video track.\n    // TODO: This does not handle changes in orientation after a track got published (e.g when rotating a phone camera from portrait to landscape).\n    if (\n      typeof publication?.dimensions?.width === 'number' &&\n      typeof publication?.dimensions?.height === 'number'\n    ) {\n      const orientation_ =\n        publication.dimensions.width > publication.dimensions.height ? 'landscape' : 'portrait';\n      setOrientation(orientation_);\n    }\n  }, [publication]);\n\n  return {\n    publication,\n    isMuted,\n    isSubscribed,\n    track,\n    elementProps: mergeProps(options.props, {\n      className,\n      'data-lk-local-participant': observerOptions.participant.isLocal,\n      'data-lk-source': publication?.source,\n      ...(publication?.kind === 'video' && { 'data-lk-orientation': orientation }),\n    }),\n  };\n}\n","import * as React from 'react';\nimport { mergeProps as mergePropsReactAria } from './mergeProps';\nimport { log } from '@livekit/components-core';\n\n/** @internal */\nexport function isProp<U extends HTMLElement, T extends React.HTMLAttributes<U>>(\n  prop: T | undefined,\n): prop is T {\n  return prop !== undefined;\n}\n\n/** @internal */\nexport function mergeProps<\n  U extends HTMLElement,\n  T extends Array<React.HTMLAttributes<U> | undefined>,\n>(...props: T) {\n  return mergePropsReactAria(...props.filter(isProp));\n}\n\n/** @internal */\nexport function cloneSingleChild(\n  children: React.ReactNode | React.ReactNode[],\n  props?: Record<string, any>,\n  key?: any,\n) {\n  return React.Children.map(children, (child) => {\n    // Checking isValidElement is the safe way and avoids a typescript\n    // error too.\n    if (React.isValidElement(child) && React.Children.only(children)) {\n      return React.cloneElement(child, { ...props, key });\n    }\n    return child;\n  });\n}\n\n/**\n * @internal\n */\nexport function warnAboutMissingStyles(el?: HTMLElement) {\n  if (\n    // eslint-disable-next-line turbo/no-undeclared-env-vars\n    (process?.env?.NODE_ENV === 'dev' || process?.env?.NODE_ENV === 'development') &&\n    typeof window !== 'undefined'\n  ) {\n    const target = el ?? document.querySelector('.lk-room-container');\n    if (target && !getComputedStyle(target).getPropertyValue('--lk-has-imported-styles')) {\n      log.warn(\n        \"It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page.\",\n      );\n    }\n  }\n}\n","import type { VideoSource, AudioSource } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context/participant-context';\nimport type * as React from 'react';\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\n\n/** @public */\nexport interface UseMediaTrackOptions {\n  element?: React.RefObject<HTMLMediaElement>;\n  props?: React.HTMLAttributes<HTMLVideoElement | HTMLAudioElement>;\n}\n\n/**\n * @public\n * @deprecated use `useTrack` instead\n *  */\nexport function useMediaTrack(\n  source: VideoSource | AudioSource,\n  participant?: Participant,\n  options: UseMediaTrackOptions = {},\n) {\n  const p = useEnsureParticipant(participant);\n  return useMediaTrackBySourceOrName({ source, participant: p }, options);\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport type { UseMediaTrackOptions } from './useMediaTrack';\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\n\n/**\n * @public\n * @deprecated This function will be removed in a future version, use `useTrackByName` instead.\n */\nexport function useMediaTrackByName(\n  name: string,\n  participant?: Participant,\n  options: UseMediaTrackOptions = {},\n) {\n  const p = useEnsureParticipant(participant);\n  return useMediaTrackBySourceOrName({ name, participant: p }, options);\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\n\n/**\n * The `usePagination` hook implements simple pagination logic for use with arrays.\n * @example\n * ```tsx\n * const tracks = useTracks();\n * const pagination = usePagination(4, tracks);\n *\n * <TrackLoop tracks={pagination.tracks} />\n * ```\n * @alpha\n */\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\n  if (currentPage > totalPageCount) {\n    setCurrentPage(totalPageCount);\n  }\n  const lastItemIndex = currentPage * itemPerPage;\n  const firstItemIndex = lastItemIndex - itemPerPage;\n\n  const changePage = (direction: 'next' | 'previous') => {\n    setCurrentPage((state) => {\n      if (direction === 'next') {\n        if (state === totalPageCount) {\n          return state;\n        }\n        return state + 1;\n      } else {\n        if (state === 1) {\n          return state;\n        }\n        return state - 1;\n      }\n    });\n  };\n\n  const goToPage = (num: number) => {\n    if (num > totalPageCount) {\n      setCurrentPage(totalPageCount);\n    } else if (num < 1) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(num);\n    }\n  };\n\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\n\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\n\n  return {\n    totalPageCount,\n    nextPage: () => changePage('next'),\n    prevPage: () => changePage('previous'),\n    setPage: goToPage,\n    firstItemIndex,\n    lastItemIndex,\n    tracks: tracksOnPage,\n    currentPage,\n  };\n}\n\nexport default usePagination;\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseVisualStableUpdateOptions {\n  /** Overwrites the default sort function. */\n  customSortFunction?: (\n    trackReferences: TrackReferenceOrPlaceholder[],\n  ) => TrackReferenceOrPlaceholder[];\n}\n\n/**\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\n * in an array. The algorithm only starts to update when there are more items than visually fit\n * on a page. If this is the case, it will make sure that speaking participants move to the first\n * page and are always visible.\n * @remarks\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\n * or start speaking.\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\n *\n * @example\n * ```tsx\n * const trackRefs = useTracks();\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\n * ```\n * @public\n */\nexport function useVisualStableUpdate(\n  /** `TrackReference`s to display in the grid.  */\n  trackReferences: TrackReferenceOrPlaceholder[],\n  maxItemsOnPage: number,\n  options: UseVisualStableUpdateOptions = {},\n): TrackReferenceOrPlaceholder[] {\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\n\n  const sortedTrackRefs =\n    typeof options.customSortFunction === 'function'\n      ? options.customSortFunction(trackReferences)\n      : sortTrackReferences(trackReferences);\n\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\n  if (layoutChanged === false) {\n    try {\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\n    } catch (error) {\n      log.error('Error while running updatePages(): ', error);\n    }\n  }\n\n  // Save info for to compare against in the next update cycle.\n  if (layoutChanged) {\n    lastTrackRefs.current = sortedTrackRefs;\n  } else {\n    lastTrackRefs.current = updatedTrackRefs;\n  }\n  lastMaxItemsOnPage.current = maxItemsOnPage;\n\n  return updatedTrackRefs;\n}\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  const p = useEnsureParticipant(props.participant);\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p.name,\n    identity: p.identity,\n    metadata: p.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import * as React from 'react';\nimport type { Participant } from 'livekit-client';\nimport { participantPermissionObserver } from '@livekit/components-core';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(options: UseParticipantPermissionsOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupParticipantTile } from '@livekit/components-core';\nimport type { TrackPublication, Participant } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeTrackRefContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useFacingMode } from './useFacingMode';\nimport { useIsMuted } from './useIsMuted';\nimport { useIsSpeaking } from './useIsSpeaking';\n\n/** @public */\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\n  /** The track reference to display. */\n  trackRef?: TrackReferenceOrPlaceholder;\n  disableSpeakingIndicator?: boolean;\n  /** @deprecated This parameter will be removed in a future version use `trackRef` instead. */\n  publication?: TrackPublication;\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\n  htmlProps: React.HTMLAttributes<T>;\n  /** @deprecated This parameter will be removed in a future version use `trackRef` instead. */\n  source?: Track.Source;\n  /** @deprecated This parameter will be removed in a future version use `trackRef` instead. */\n  participant?: Participant;\n}\n\n/**\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\n * @remarks\n * The returned props include many data attributes that are useful for CSS styling purposes because they\n * indicate the state of the participant and the track.\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\n * @public\n */\nexport function useParticipantTile<T extends HTMLElement>({\n  trackRef,\n  participant,\n  source,\n  publication,\n  onParticipantClick,\n  disableSpeakingIndicator,\n  htmlProps,\n}: UseParticipantTileProps<T>) {\n  // TODO: Remove and refactor after deprecation period to use:\n  // const trackReference = useEnsureTrackRefContext(trackRef)`.\n  const maybeTrackRef = useMaybeTrackRefContext();\n  const p = useEnsureParticipant(participant);\n  const trackReference = React.useMemo(() => {\n    const _source = trackRef?.source ?? maybeTrackRef?.source ?? source;\n    if (_source === undefined) {\n      throw new Error(\n        'Missing track `source`, provided it via `trackRef`, `source` property or via `TrackRefContext`.',\n      );\n    }\n    return {\n      participant: trackRef?.participant ?? maybeTrackRef?.participant ?? p,\n      publication: trackRef?.publication ?? maybeTrackRef?.publication ?? publication,\n      source: _source,\n    };\n  }, [\n    trackRef?.participant,\n    trackRef?.source,\n    trackRef?.publication,\n    maybeTrackRef?.participant,\n    maybeTrackRef?.source,\n    maybeTrackRef?.publication,\n    p,\n    source,\n    publication,\n  ]);\n\n  const mergedProps = React.useMemo(() => {\n    const { className } = setupParticipantTile();\n    return mergeProps(htmlProps, {\n      className,\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\n        htmlProps.onClick?.(event);\n        if (typeof onParticipantClick === 'function') {\n          const track =\n            trackReference.publication ??\n            trackReference.participant.getTrack(trackReference.source);\n          onParticipantClick({ participant: trackReference.participant, track });\n        }\n      },\n    });\n  }, [\n    htmlProps,\n    onParticipantClick,\n    trackReference.publication,\n    trackReference.source,\n    trackReference.participant,\n  ]);\n  const isVideoMuted = useIsMuted(Track.Source.Camera, { participant: trackReference.participant });\n  const isAudioMuted = useIsMuted(Track.Source.Microphone, {\n    participant: trackReference.participant,\n  });\n  const isSpeaking = useIsSpeaking(trackReference.participant);\n  const facingMode = useFacingMode(trackReference);\n  return {\n    elementProps: {\n      'data-lk-audio-muted': isAudioMuted,\n      'data-lk-video-muted': isVideoMuted,\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\n      'data-lk-local-participant': trackReference.participant.isLocal,\n      'data-lk-source': trackReference.source,\n      'data-lk-facing-mode': facingMode,\n      ...mergedProps,\n    } as React.HTMLAttributes<T>,\n  };\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return [localParticipant, ...remoteParticipants];\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { LayoutContextType } from '../context';\nimport { useEnsureLayoutContext } from '../context';\n\n/**\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\n * @remarks\n * To function properly, this hook must be called within a `LayoutContext`.\n * @example\n * ```tsx\n * const pinnedTracks = usePinnedTracks();\n * ```\n * @public\n */\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\n  layoutContext = useEnsureLayoutContext(layoutContext);\n  return React.useMemo(() => {\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\n      return layoutContext.pin.state;\n    }\n    return [];\n  }, [layoutContext.pin.state]);\n}\n","import { connectedParticipantObserver } from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the RemoteParticipant with the given `identity`.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(\n    () => connectedParticipantObserver(room, identity, { additionalEvents: updateOnlyOn }),\n    [room, identity, updateOnlyOn],\n  );\n  const participant = useObservableState(\n    observable,\n    room.getParticipantByIdentity(identity) as RemoteParticipant | undefined,\n  );\n  return participant;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useSpeakingParticipants` hook returns the only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants() {\n  const room = useRoomContext();\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\n  return activeSpeakers;\n}\n","import { setupStartAudio } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartAudioProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\n * that indicates whether audio playback is allowed in the current context,\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\n    () => setupStartAudio(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartAudioPlayback(roomEnsured);\n        },\n        style: { display: canPlayAudio ? 'none' : 'block' },\n      }),\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayAudio };\n}\n","import { setupStartVideo } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartVideoProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\n * that indicates whether video playback is allowed in the current context,\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\n *\n * @alpha\n */\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\n    () => setupStartVideo(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\n  );\n  const { canPlayVideo } = useObservableState(observable, {\n    canPlayVideo: roomEnsured.canPlaybackVideo,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartVideoPlayback(roomEnsured);\n        },\n        style: { display: canPlayVideo ? 'none' : 'block' },\n      }),\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayVideo };\n}\n","import * as React from 'react';\n\n/**\n * @alpha\n */\nexport type UseSwipeOptions = {\n  minSwipeDistance?: number;\n  onLeftSwipe?: () => void;\n  onRightSwipe?: () => void;\n};\n\n/**\n * Simple implementation to detect horizontal swipe actions.\n * Accepts callbacks for on right and left swipes.\n * @example\n * ```tsx\n *  <div\n      onTouchStart={onTouchStart}\n      onTouchMove={onTouchMove}\n      onTouchEnd={onTouchEnd}\n    >\n * ```\n * @alpha\n */\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\n  const touchStart = React.useRef<number | null>(null);\n  const touchEnd = React.useRef<number | null>(null);\n\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\n\n  const onTouchStart = (event: TouchEvent) => {\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\n    touchStart.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    touchEnd.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchEnd = React.useCallback(() => {\n    if (!touchStart.current || !touchEnd.current) {\n      return;\n    }\n    const distance = touchStart.current - touchEnd.current;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\n  }, [minSwipeDistance, options]);\n\n  React.useEffect(() => {\n    const elementCopy = element.current;\n    if (elementCopy) {\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\n    }\n    return () => {\n      if (elementCopy) {\n        elementCopy.removeEventListener('touchstart', onTouchStart);\n        elementCopy.removeEventListener('touchmove', onTouchMove);\n        elementCopy.removeEventListener('touchend', onTouchEnd);\n      }\n    };\n  }, [element, onTouchEnd]);\n}\n","import { setupChatToggle } from '@livekit/components-core';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseChatToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\n * @remarks\n * Depends on the `LayoutContext` to work properly.\n * @see {@link ChatToggle}, {@link Chat}\n * @public\n */\nexport function useChatToggle({ props }: UseChatToggleProps) {\n  const { dispatch, state } = useLayoutContext().widget;\n  const { className } = React.useMemo(() => setupChatToggle(), []);\n\n  const mergedProps = React.useMemo(() => {\n    return mergeProps(props, {\n      className,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\n      },\n      'aria-pressed': state?.showChat ? 'true' : 'false',\n      'data-lk-unread-msgs': state\n        ? state.unreadMessages < 10\n          ? state.unreadMessages.toFixed(0)\n          : '9+'\n        : '0',\n    });\n  }, [props, className, dispatch, state]);\n\n  return { mergedProps };\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  setupTrackMutedIndicator,\n  getTrackReferenceId,\n} from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext, useMaybeTrackRefContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackMutedIndicatorOptions {\n  /** @deprecated This parameter will be removed in a future version use `trackRef` instead. */\n  participant?: Participant;\n}\n\ninterface TrackMutedIndicatorReturnType {\n  isMuted: boolean;\n  className: string;\n}\n\n/**\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\n * and returns the muted state of the given track.\n *\n * @example\n * ```tsx\n * const { isMuted } = useTrackMutedIndicator(trackRef);\n * ```\n * @public\n */\nexport function useTrackMutedIndicator(\n  trackRef?: TrackReferenceOrPlaceholder,\n): TrackMutedIndicatorReturnType;\n/** @public @deprecated This overload will be removed in a future version, pass in trackRef instead. */\nexport function useTrackMutedIndicator(\n  source: Track.Source,\n  options?: UseTrackMutedIndicatorOptions,\n): TrackMutedIndicatorReturnType;\nexport function useTrackMutedIndicator(\n  trackRefOrSource?: TrackReferenceOrPlaceholder | Track.Source,\n  options: UseTrackMutedIndicatorOptions = {},\n): TrackMutedIndicatorReturnType {\n  let ref = useMaybeTrackRefContext();\n  const p = useMaybeParticipantContext() ?? options.participant ?? ref?.participant;\n\n  if (typeof trackRefOrSource === 'string') {\n    if (!p) {\n      throw Error(`Participant missing, either provide it via context or pass it in directly`);\n    }\n    ref = { participant: p, source: trackRefOrSource };\n  } else if (trackRefOrSource) {\n    ref = trackRefOrSource;\n  } else {\n    throw Error(`No track reference found, either provide it via context or pass it in directly`);\n  }\n\n  const { className, mediaMutedObserver } = React.useMemo(\n    () => setupTrackMutedIndicator(ref as TrackReferenceOrPlaceholder),\n    [getTrackReferenceId(ref)],\n  );\n\n  const isMuted = useObservableState(\n    mediaMutedObserver,\n    !!(ref.publication?.isMuted || ref.participant.getTrack(ref.source)?.isMuted),\n  );\n\n  return { isMuted, className };\n}\n","import type { ToggleSource } from '@livekit/components-core';\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { TrackToggleProps } from '../components';\nimport { useMaybeRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackToggleProps<T extends ToggleSource>\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {}\n\n/**\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\n * and functionality of the given track.\n *\n * @example\n * ```tsx\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\n * ```\n * @public\n */\nexport function useTrackToggle<T extends ToggleSource>({\n  source,\n  onChange,\n  initialState,\n  captureOptions,\n  ...rest\n}: UseTrackToggleProps<T>) {\n  const room = useMaybeRoomContext();\n  const track = room?.localParticipant?.getTrack(source);\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\n  const userInteractionRef = React.useRef(false);\n\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\n    () => (room ? setupMediaToggle<T>(source, room, captureOptions) : setupManualToggle()),\n    [room, source, JSON.stringify(captureOptions)],\n  );\n\n  const pending = useObservableState(pendingObserver, false);\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\n\n  React.useEffect(() => {\n    onChange?.(enabled, userInteractionRef.current);\n    userInteractionRef.current = false;\n  }, [enabled, onChange]);\n\n  React.useEffect(() => {\n    if (initialState !== undefined) {\n      log.debug('forcing initial toggle state', source, initialState);\n      toggle(initialState);\n    }\n    // only execute once at the beginning\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\n\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\n    (evt) => {\n      userInteractionRef.current = true;\n      toggle().finally(() => (userInteractionRef.current = false));\n      rest.onClick?.(evt);\n    },\n    [rest, toggle],\n  );\n\n  return {\n    toggle,\n    enabled,\n    pending,\n    track,\n    buttonProps: {\n      ...newProps,\n      'aria-pressed': enabled,\n      'data-lk-source': source,\n      'data-lk-enabled': enabled,\n      disabled: pending,\n      onClick: clickHandler,\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\n  };\n}\n","import type {\n  SourcesArray,\n  TrackReference,\n  TrackReferenceOrPlaceholder,\n  TrackSourceWithOptions,\n  TrackReferencePlaceholder,\n} from '@livekit/components-core';\nimport {\n  isSourcesWithOptions,\n  isSourceWitOptions,\n  log,\n  trackReferencesObservable,\n} from '@livekit/components-core';\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport type UseTracksOptions = {\n  updateOnlyOn?: RoomEvent[];\n  onlySubscribed?: boolean;\n  room?: Room;\n};\n\n/** @public */\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\n  ? TrackReference[]\n  : T extends TrackSourceWithOptions[]\n  ? TrackReferenceOrPlaceholder[]\n  : never;\n\n/**\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\n * @example\n * ```ts\n * // Return all camera track publications.\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\n * ```\n * @example\n * ```ts\n * // Return all subscribed camera tracks as well as placeholders for\n * // participants without a camera subscription.\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\n * ```\n * @public\n */\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\n  sources: T = [\n    Track.Source.Camera,\n    Track.Source.Microphone,\n    Track.Source.ScreenShare,\n    Track.Source.ScreenShareAudio,\n    Track.Source.Unknown,\n  ] as T,\n  options: UseTracksOptions = {},\n): UseTracksHookReturnType<T> {\n  const room = useEnsureRoom(options.room);\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\n\n  const sources_ = React.useMemo(() => {\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\n  }, [JSON.stringify(sources)]);\n\n  React.useEffect(() => {\n    const subscription = trackReferencesObservable(room, sources_, {\n      additionalRoomEvents: options.updateOnlyOn,\n      onlySubscribed: options.onlySubscribed,\n    }).subscribe(({ trackReferences, participants }) => {\n      log.debug('setting track bundles', trackReferences, participants);\n      setTrackReferences(trackReferences);\n      setParticipants(participants);\n    });\n    return () => subscription.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn), JSON.stringify(sources)]);\n\n  const maybeTrackReferences = React.useMemo(() => {\n    if (isSourcesWithOptions(sources)) {\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\n        Array.from(trackReferences);\n      participants.forEach((participant) => {\n        if (requirePlaceholder.has(participant.identity)) {\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\n            if (\n              trackReferences.find(\n                ({ participant: p, publication }) =>\n                  participant.identity === p.identity && publication.source === placeholderSource,\n              )\n            ) {\n              return;\n            }\n            log.debug(\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\n            );\n            const placeholder: TrackReferencePlaceholder = {\n              participant,\n              source: placeholderSource,\n            };\n            trackReferencesWithPlaceholders.push(placeholder);\n          });\n        }\n      });\n      return trackReferencesWithPlaceholders;\n    } else {\n      return trackReferences;\n    }\n  }, [trackReferences, participants, sources]);\n\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\n}\n\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\nexport function requiredPlaceholders<T extends SourcesArray>(\n  sources: T,\n  participants: Participant[],\n): Map<Participant['identity'], Track.Source[]> {\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\n  if (isSourcesWithOptions(sources)) {\n    const sourcesThatNeedPlaceholder = sources\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\n      .map((sourceWithOption) => sourceWithOption.source);\n\n    participants.forEach((participant) => {\n      const sourcesOfSubscribedTracks = participant\n        .getTracks()\n        .map((pub) => pub.track?.source)\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\n      const placeholderNeededForThisParticipant = Array.from(\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\n      );\n      // If the participant needs placeholder add it to the placeholder map.\n      if (placeholderNeededForThisParticipant.length > 0) {\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\n      }\n    });\n  }\n  return placeholderMap;\n}\n","import type { TrackIdentifier } from '@livekit/components-core';\nimport type * as React from 'react';\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\n\n/** @public */\nexport interface UseTrackOptions {\n  element?: React.RefObject<HTMLMediaElement>;\n  props?: React.HTMLAttributes<HTMLVideoElement | HTMLAudioElement>;\n}\n\n/** @public */\nexport function useTrack(trackRef: TrackIdentifier, options: UseTrackOptions = {}) {\n  return useMediaTrackBySourceOrName(trackRef, options);\n}\n","import { useEnsureTrackRef } from '../context';\nimport type { UseMediaTrackOptions } from './useMediaTrack';\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\nimport type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\n\n/**\n * @public\n */\nexport function useTrackByName(\n  trackRef?: TrackReferenceOrPlaceholder,\n  options: UseMediaTrackOptions = {},\n) {\n  const ref = useEnsureTrackRef(trackRef);\n  return useMediaTrackBySourceOrName(ref, options);\n}\n","import type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\nimport { setupChat } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useChat` hook provides chat functionality for a LiveKit room.\n * It returns a simple `send` function to send chat messages and an array of `chatMessages` to hold received messages.\n * It also returns a `update` function that allows you to implement message-edit functionality.\n * @remarks\n * It is possible to pass configurations for custom message encoding and decoding and non-default topics on which to send the messages.\n * @public\n */\nexport function useChat(options?: ChatOptions) {\n  const room = useRoomContext();\n  const [setup, setSetup] = React.useState<ReturnType<typeof setupChat>>();\n  const isSending = useObservableState(setup?.isSendingObservable, false);\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup?.messageObservable, []);\n\n  React.useEffect(() => {\n    const setupChatReturn = setupChat(room, options);\n    setSetup(setupChatReturn);\n  }, [room, options]);\n\n  return { send: setup?.send, update: setup?.update, chatMessages, isSending };\n}\n","import type { LocalUserChoices } from '@livekit/components-core';\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\nimport * as React from 'react';\n\n/**\n * Options for the `usePersistentDeviceSettings` hook.\n * @alpha\n */\nexport interface UsePersistentUserChoicesOptions {\n  /**\n   * The default value to use if reading from local storage returns no results or fails.\n   */\n  defaults?: Partial<LocalUserChoices>;\n  /**\n   * Whether to prevent saving to persistent storage.\n   * @defaultValue false\n   */\n  preventSave?: boolean;\n  /**\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\n   * @defaultValue false\n   */\n  preventLoad?: boolean;\n}\n\n/**\n * A hook that provides access to user choices stored in local storage, such as\n * selected media devices and their current state (on or off), as well as the user name.\n * @alpha\n */\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\n  );\n\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\n  }, []);\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\n  }, []);\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\n  }, []);\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\n  }, []);\n  const saveUsername = React.useCallback((username: string) => {\n    setSettings((prev) => ({ ...prev, username: username }));\n  }, []);\n\n  React.useEffect(() => {\n    saveUserChoices(userChoices, options.preventSave ?? false);\n  }, [userChoices, options.preventSave]);\n\n  return {\n    userChoices,\n    saveAudioInputEnabled,\n    saveVideoInputEnabled,\n    saveAudioInputDeviceId,\n    saveVideoInputDeviceId,\n    saveUsername,\n  };\n}\n","import * as React from 'react';\nimport { LocalParticipant, Participant } from 'livekit-client';\nimport { encryptionStatusObservable } from '@livekit/components-core';\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * @alpha\n */\nexport function useIsEncrypted(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const room = useEnsureRoom();\n\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\n  const isEncrypted = useObservableState(\n    observer,\n    p instanceof LocalParticipant ? p.isE2EEEnabled : p.isEncrypted,\n  );\n  return isEncrypted;\n}\n","import * as React from 'react';\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\nimport { Track, createAudioAnalyser } from 'livekit-client';\nimport {\n  type TrackReference,\n  isTrackReference,\n  type TrackReferenceOrPlaceholder,\n} from '@livekit/components-core';\n\n/**\n * @alpha\n * Hook for tracking the volume of an audio track using the Web Audio API.\n */\nexport const useTrackVolume = (\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\n) => {\n  const track = isTrackReference(trackOrTrackReference)\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\n    : trackOrTrackReference;\n  const [volume, setVolume] = React.useState(0);\n  React.useEffect(() => {\n    if (!track || !track.mediaStream) {\n      return;\n    }\n\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getByteFrequencyData(dataArray);\n      let sum = 0;\n      for (let i = 0; i < dataArray.length; i++) {\n        const a = dataArray[i];\n        sum += a * a;\n      }\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\n    };\n\n    const interval = setInterval(updateVolume, 1000 / 30);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return volume;\n};\n\nconst normalizeFrequencies = (frequencies: Float32Array) => {\n  const normalizeDb = (value: number) => {\n    const minDb = -100;\n    const maxDb = -10;\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\n    db = Math.sqrt(db);\n\n    return db;\n  };\n\n  // Normalize all frequency values\n  return frequencies.map((value) => {\n    if (value === -Infinity) {\n      return 0;\n    }\n    return normalizeDb(value);\n  });\n};\n\n/**\n * Interface for configuring options for the useMultibandTrackVolume hook.\n * @alpha\n */\nexport interface MultiBandTrackVolumeOptions {\n  bands?: number;\n  /**\n   * cut off of frequency bins on the lower end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  loPass?: number;\n  /**\n   * cut off of frequency bins on the higher end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  hiPass?: number;\n  /**\n   * update should run every x ms\n   */\n  updateInterval?: number;\n  analyserOptions?: AnalyserOptions;\n}\n\nconst multibandDefaults = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 10,\n  analyserOptions: { fftSize: 2048 },\n} as const satisfies MultiBandTrackVolumeOptions;\n\n/**\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\n * @alpha\n */\nexport const useMultibandTrackVolume = (\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: MultiBandTrackVolumeOptions = {},\n) => {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>([]);\n  const opts = { ...multibandDefaults, ...options };\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Float32Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getFloatFrequencyData(dataArray);\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\n      for (let i = 0; i < dataArray.length; i++) {\n        frequencies[i] = dataArray[i];\n      }\n      frequencies = frequencies.slice(options.loPass, options.hiPass);\n\n      const normalizedFrequencies = normalizeFrequencies(frequencies);\n      const chunkSize = Math.ceil(normalizedFrequencies.length / opts.bands);\n      const chunks: Array<number> = [];\n      for (let i = 0; i < opts.bands; i++) {\n        const summedVolumes = normalizedFrequencies\n          .slice(i * chunkSize, (i + 1) * chunkSize)\n          .reduce((acc, val) => (acc += val), 0);\n        chunks.push(summedVolumes / chunkSize);\n      }\n\n      setFrequencyBands(chunks);\n    };\n\n    const interval = setInterval(updateVolume, opts.updateInterval);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return frequencyBands;\n};\n"],"mappings":"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","names":["React","useLatest","React","import_components_core","React","React","React","React","import_components_core","React","clsx","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","import_livekit_client","React","import_livekit_client","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","import_livekit_client","React","import_components_core","React","import_components_core","React","import_components_core","React","React","import_components_core","import_components_core","React","React","import_components_core","mergeProps","publication","_a","mergeProps","React","import_components_core","React","import_components_core","React","React","import_components_core","import_components_core","import_livekit_client","React","import_components_core","React","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","roomAudioPlaybackAllowedObservable","import_components_core","React","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","_a","import_components_core","import_livekit_client","React","trackReferences","participants","import_components_core","React","import_components_core","React","_a","React","import_livekit_client","import_components_core","React","import_livekit_client","import_components_core"]}